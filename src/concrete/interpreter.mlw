
module Interpreter

  use list.List
  use list.Append
  use ref.Ref
  use option.Option
  use bool.Bool

  use mystring.String
  use syntax.Syntax
  use semantics.Strict
  use semantics.Filesystem
  use semantics.Buffers
  use semantics.Behaviour
  use semantics.Context
  use semantics.Semantics

  let ([<-]) (m:variable -> 'a) (var:variable) (value:'a) : variable -> 'a
  = fun var1 ->
      if variable_eq var1 var
      then value
      else m var1

  exception EExit bool
  
  let result_or_exit (strict:strict) (b:bool) : bool
    raises { EExit _ -> true }
  = match strict, b with
    | Strict True, False -> raise (EExit b)
    | _ -> b
    end

  let result_or_exit_opt (strict:strict) (bo:option bool) : bool
    raises { EExit _ -> true }
  = match bo with
    | Some b -> result_or_exit strict b
    | None -> True
    end

  (* We use refs instead of mutable fields to be able to reuse `stdin` (and `stdout`) but
     shadow `senv`. *)
  type state = {
    senv : ref senv;
    stdin : ref stdin;
    stdout : ref stdout;
    filesystem : ref filesystem;
  }

  let empty_state () = {
    senv = ref empty_senv;
    stdin = ref empty_stdin;
    stdout = ref empty_stdout;
    filesystem = ref empty_filesystem;
  }

  let function context (sta:state) : Context.context = {
    Context.senv = !(sta.senv)
  }

  let function state (sta:state) : Context.state = {
    Context.filesystem = !(sta.filesystem);
    Context.stdin = !(sta.stdin)
  }

  let function normal_output (old_sta sta:state) (b:bool) : Context.output = {
    Context.behaviour = BNormal b;
    Context.stdout = diff !(old_sta.stdout) !(sta.stdout)
  }

  let function exit_output (old_sta sta:state) (b:bool) : Context.output = {
    Context.behaviour = BExit b;
    Context.stdout = diff !(old_sta.stdout) !(sta.stdout)
  }

  let interp_builtin sta name args =
    let sta', out, b = Semantics.interp_builtin (state sta) name args in
    sta.filesystem := sta'.Context.filesystem;
    sta.stdin := sta'.Context.stdin;
    sta.stdout := append !(sta.stdout) out;
    b
  
  (* See NOTES[Concrete interpreter type] for discussion on arguments.

     TODO
     - Can we make the fields of `state` global variables?
     - Can we use s/`previous_result`/`result`/ instead of returning or raising a value?
   *)
  let rec interp_stmt (inp:input) (sta:state) (stm:statement) : bool
    returns { b ->
      eval_stmt inp (context (old sta)) (state (old sta))
        stm (state sta) (context sta) (normal_output (old sta) (sta) b)
    }
    raises { EExit b ->
      eval_stmt inp (context (old sta)) (state (old sta))
        stm (state sta) (context sta) (exit_output (old sta) (sta) b)
    }
    raises  { EExit _ -> not inp.under_condition }
  = match stm with

    | SExit code ->
      let b =
        match code with
        | CPrevious -> inp.previous_result
        | CFailure -> False
        | CSuccess -> True
        end
      in
      raise (EExit b)

    | SAssignment var se ->
      let str, bo = interp_str_expr inp sta se in
      sta.senv := !(sta.senv)[var <- str];
      result_or_exit_opt (strict inp) bo

    | SSequence stm1 stm2 ->
      let b = interp_stmt inp sta stm1 in
      interp_stmt {inp with previous_result = b} sta stm2

    | SSubshell stm ->
      (* Don't override `sta.senv` in the subshell *)
      let sta' = {sta with senv = ref !(sta.senv)} in
      interp_stmt inp sta' stm

    | SNot stm ->
      notb (interp_stmt {inp with under_condition=True} sta stm)

    | SIf stm1 stm2 stm3 ->
      if interp_stmt {inp with under_condition=True} sta stm1 then
        interp_stmt inp sta stm2
      else
        interp_stmt inp sta stm3

    | SNoOutput stm ->
      let sta' = {sta with stdout = ref empty_stdout} in
      interp_stmt inp sta' stm

    | SPipe stm1 stm2 ->
      let sta' = {sta with stdout = ref empty_stdout} in
      try let _ = interp_stmt inp sta' stm1 in ()
      with EExit _ -> () end;
      let sta'' = {sta with stdin = ref (stdout_to_stdin !(sta'.stdout))} in
      interp_stmt inp sta'' stm2

    | SCall name le ->
      let args = interp_list_expr inp sta le in
      let b = interp_builtin sta name args in
      result_or_exit (strict inp) b

    | SForeach var le stm ->
      let ss = interp_list_expr inp sta le in
      let rec aux prev ss =
        match ss with
        | Nil -> prev
        | Cons s ss' ->
          sta.senv := !(sta.senv)[var <- s];
          let b = interp_stmt {inp with previous_result=prev} sta stm in
          aux b ss'
        end
      (* See NOTES[Previous in for-loop] for p=True *)
      in aux True ss

    | SWhile _ _ -> absurd
    end

  with interp_str_expr (inp:input) (sta:state) (se:string_expression) : (string, option bool)
  = match se with
    | ELiteral s -> s, None
    | EVariable v -> !(sta.senv) v, None  (* Why3 bug: Map__Map is not created - cannot use ctx.senv[v] *)
    | ESubshell stm ->
      let sta' = {sta with stdout = ref empty_stdout} in
      let b =
        try interp_stmt inp sta' stm
        with EExit b -> b end
      in
      let str = string_from_stdout !(sta'.stdout) in
      str, Some b
    | EConcat se1 se2 ->
      let s1, bo1 = interp_str_expr inp sta se1 in
      let s2, bo2 = interp_str_expr inp sta se2 in
      let bo3 = bool_opt_compose bo1 bo2 in
      s1^s2, bo3
    end

  with interp_list_expr (inp:input) (sta:state) (le:list_expression) : list string
  = match le with
    | Nil -> Nil
    | Cons (se, sp) le_rest ->
      let s, _ = interp_str_expr inp sta se in
      let l1 = match sp with Split True -> split s | Split False -> Cons s Nil end in
      let l2 = interp_list_expr inp sta le_rest in
      let l3 = l1 ++ l2 in
      l3
    end
end