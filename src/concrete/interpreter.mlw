(** {1 An imperative interpreter of the CoLiS Language}

    See NOTES[Concrete interpreter type] for discussion on arguments.
 *)

module Interpreter

  use list.List
  use list.Append
  use ref.Ref
  use option.Option
  use bool.Bool
  use map.MapExt

  use mystring.String
  use syntax.Syntax
  use semantics.Filesystem
  use semantics.Buffers
  use semantics.Behaviour
  use semantics.Env
  use semantics.Context as C
  use semantics.Semantics

  (** {3 A purely imparative state} *)

  (* We use refs instead of mutable fields to be able to reuse `stdin` (and `stdout`) but
     shadow `senv`. *)
  type state = {
    filesystem : ref filesystem;
    var_env : ref C.var_env;
    func_env : C.func_env;
    arguments: ref (list string);
    stdin : ref stdin;
    stdout : ref stdout;
    result : ref bool;
  }

  let empty_state () = {
    filesystem = ref empty_filesystem;
    var_env = ref C.empty_var_env;
    func_env = C.empty_func_env;
    arguments = ref Nil;
    stdin = ref Stdin.empty;
    stdout = ref Stdout.empty;
    result = ref True;
  }

  (** {4 Conversion to `semantics.Context`} *)

  function context (sta:state) : C.context = {
    C.arguments = !(sta.arguments);
    C.var_env = !(sta.var_env);
    C.func_env = sta.func_env;
  }

  lemma context_same: forall sta1 sta2.
    !(sta1.var_env) == !(sta2.var_env) ->
    context sta1 = context sta2

  let function state (sta:state) : C.state = {
    C.filesystem = !(sta.filesystem);
    C.stdin = !(sta.stdin);
    C.stdout = !(sta.stdout)
  }

  (** {3 The input type} *)

  type input = {
    argument0: string;
    under_condition: bool;
  }

  let constant empty_input = {
    argument0 = String.empty;
    under_condition = False;
  }

  let function input (inp:input) (sta:state) : C.input = {
    C.argument0 = inp.argument0;
    C.under_condition = inp.under_condition;
    C.previous_result = !(sta.result);
  }

  lemma input_same : forall inp inp' sta sta'.
    inp.argument0 = inp'.argument0 ->
    inp.under_condition = inp'.under_condition ->
    !(sta.result) = !(sta'.result) ->
    input inp sta = input inp' sta'

  (** {3 The exit exception} *)

  exception EExit
  exception EReturn

  let maybe_exit (inp:input) (sta:state) : unit
    returns { () ->
      inject_behaviour (input inp sta) !(sta.result) = BNormal !(sta.result)
    }
    raises { EExit ->
      inject_behaviour (input inp sta) !(sta.result) = BExit !(sta.result)
    }
  = if andb (strict inp.under_condition) (notb !(sta.result)) then
      raise EExit

  (** {3 Imperative wrapper around the functional interpretation of utilties} *)

  let interp_utility inp sta name args raises { EExit -> true }
  = let sta', b = Semantics.interp_utility (state sta) name args in
    sta.filesystem := sta'.C.filesystem;
    sta.stdin := sta'.C.stdin;
    sta.stdout := sta'.C.stdout;
    sta.result := b;
    maybe_exit inp sta

  let shift_arguments sta n
    ensures {
      !(sta.result) = True ->
      shift_arguments !((old sta).arguments) n = Some !(sta.arguments)
    }
    ensures {
      !(sta.result) = False ->
      shift_arguments !((old sta).arguments) n = None /\
      !(sta.arguments) = !((old sta).arguments)
    }
  = try
      let new_args = ref !(sta.arguments) in
      for i = 1 to n do
        match !new_args with
        | Cons _ args' ->
          new_args := args'
        | Nil ->
          raise EExit
        end
      done;
      sta.arguments := !new_args;
      sta.result := True
    with EExit ->
      sta.result := False
    end
  
  (** {3 The interpretation of statements} *)

  let rec interp_instruction (inp:input) (sta:state) (ins:instruction) : unit
    diverges
    returns { () ->
      eval_instruction (input inp (old sta)) (context (old sta)) (state (old sta))
        ins (state sta) (context sta) (BNormal !(sta.result))
    }
    raises { EReturn ->
      eval_instruction (input inp (old sta)) (context (old sta)) (state (old sta))
        ins (state sta) (context sta) (BReturn !(sta.result))
    }
    raises { EExit ->
      eval_instruction (input inp (old sta)) (context (old sta)) (state (old sta))
        ins (state sta) (context sta) (BExit !(sta.result))
    }
  = label L in match ins with

    | IExit code ->
      match code with
      | RPrevious -> ()
      | RSuccess -> sta.result := True
      | RFailure -> sta.result := False
      end;
      assert { !(sta.result) = bool_of_return_code code !(sta.result at L) };
      raise EExit

    | IReturn code ->
      match code with
      | RPrevious -> ()
      | RSuccess -> sta.result := True
      | RFailure -> sta.result := False
      end;
      assert { !(sta.result) = bool_of_return_code code !(sta.result at L) };
      raise EReturn

    | IShift bn ->
      shift_arguments sta (option_get 1 bn);
      maybe_exit inp sta

    | IAssignment id se ->
      let str, bo = interp_str_expr inp sta se in
      sta.var_env := !(sta.var_env)[id <- str];
      sta.result := option_get True bo;
      maybe_exit inp sta

    | ISequence ins1 ins2 ->
      interp_instruction inp sta ins1;
      interp_instruction inp sta ins2

    | ISubshell ins ->
      (* Don't change `sta.senv` in the subshell *)
      let sta' = {
        sta with
        var_env = ref !(sta.var_env)
      } in
      try
        interp_instruction inp sta' ins
      with
        | EExit -> ()
        | EReturn -> ()
      end;
      maybe_exit inp sta

    | INot ins ->
      try
        interp_instruction { inp with under_condition=True } sta ins;
      with
        | EReturn ->
          sta.result := notb !(sta.result);
          raise EReturn
      end;
      sta.result := notb !(sta.result)

    | IIf ins1 ins2 ins3 ->
      interp_instruction {inp with under_condition=True} sta ins1;
      if !(sta.result) then
        interp_instruction inp sta ins2
      else
        interp_instruction inp sta ins3

    | INoOutput ins ->
      (* Donâ€™t write to `sta.stdout` *)
      let sta' = {sta with stdout = ref Stdout.empty} in
      interp_instruction inp sta' ins

    | IPipe ins1 ins2 ->
      let sta' = {
        sta with
        var_env = ref !(sta.var_env);
        stdout = ref Stdout.empty
      } in
      try
        interp_instruction inp sta' ins1
      with
        | EExit _ -> ()
        | EReturn _ -> ()
      end;
      let sta'' = {
        sta' with
        var_env = ref !(sta.var_env);
        stdout = sta.stdout;
        stdin = ref (Stdout.to_stdin !(sta'.stdout))
      } in
      interp_instruction inp sta'' ins2

    | ICallUtility name le ->
      let args = interp_list_expr inp sta le in
      interp_utility inp sta name args

    | ICallFunction id le ->
      let args = interp_list_expr inp sta le in
      match sta.func_env id with
      | None ->
        sta.result := False;
        maybe_exit inp sta
      | Some ins ->
        try
          let inp' = {
            inp with
            argument0 = identifier_to_string id
          } in
          let sta' = {
            sta with
            arguments = ref args;
            var_env = ref !(sta.var_env)
          } in
          interp_instruction inp' sta' ins
        with
          EReturn -> ()
        end
      end

    | IForeach id le ins ->
      let ss = interp_list_expr inp sta le in
      let last_result = ref True in
      let rec foreach ss =
        match ss with
        | Nil -> ()
        | Cons s ss' ->
          sta.var_env := !(sta.var_env)[id <- s];
          interp_instruction inp sta ins;
          last_result := !(sta.result);
          foreach ss'
        end
      in foreach ss;
      sta.result := !last_result (* See NOTES[Previous in for-loop] for p=True *)

    | IWhile ins1 ins2 ->
      let last_result = ref True in
      while (
        interp_instruction {inp with under_condition=True} sta ins1;
        !(sta.result)
      ) do
        interp_instruction inp sta ins2;
        last_result := !(sta.result);
      done;
      sta.result := !last_result
    end

  with interp_str_expr (inp:input) (sta:state) (se:string_expression) : (string, option bool)
    diverges
    ensures { context sta = context (old sta) }
    returns { s, bo ->
      eval_str_expr (input inp (old sta)) (context (old sta)) (state (old sta))
        se (state sta) s bo
    }
  = match se with

    | SLiteral s ->
      s, None

    | SVariable id ->
      !(sta.var_env) id, None  (* Why3 bug: Map__Map is not created - cannot use ctx.senv[id] *)

    | SArgument n ->
      nth_argument (Cons inp.argument0 !(sta.arguments)) n, None

    | SSubshell ins ->
      let sta' = {
        sta with
        stdout = ref Stdout.empty;
        result = ref !(sta.result);
        var_env = ref !(sta.var_env)
      } in
      try
        interp_instruction inp sta' ins
      with
        | EExit -> ()
        | EReturn -> ()
      end;
      stdout_to_string !(sta'.stdout), Some !(sta'.result)

    | SConcat se1 se2 ->
      label L1 in let s1, bo1 = interp_str_expr inp sta se1 in
      assert { eval_str_expr (input inp (sta at L1)) (context (sta at L1)) (state (sta at L1)) se1 (state sta) s1 bo1 };
      label L2 in let s2, bo2 = interp_str_expr inp sta se2 in
      assert { eval_str_expr (input inp (sta at L1)) (context (sta at L2)) (state (sta at L2)) se2 (state sta) s2 bo2 };
      let bo3 = bool_opt_compose bo1 bo2 in
      s1^s2, bo3
    end

  with interp_list_expr (inp:input) (sta:state) (le:list_expression) : list string
    diverges
    ensures { context sta = context (old sta) }
    returns { ss ->
      eval_list_expr (input inp (old sta)) (context (old sta)) (state (old sta))
        le (state sta) ss
    }
  = match le with
    | Nil -> Nil
    | Cons (se, sp) le_rest ->
      let s, _ = interp_str_expr inp sta se in
      let l1 = match sp with Split -> String.split_on_default_ifs s | DontSplit -> Cons s Nil end in
      let l2 = interp_list_expr inp sta le_rest in
      l1 ++ l2
    end

  use list.FoldLeft

  let interp_program inp sta pro
    diverges
    returns { () ->
      eval_program (input inp (old sta)) (context (old sta)) (state (old sta))
        pro (state sta) (context sta) !(sta.result)
    }
  = try
      let rec aux e defs variant { defs } =
        match defs with
        | Nil -> e
        | Cons (id, instr) defs' ->
          aux e[id <- Some instr]  defs'
        end
      in
      let e = aux sta.func_env pro.function_definitions in
      interp_instruction inp { sta with func_env = e } pro.instruction
    with
      | EExit -> ()
      | EReturn -> ()
    end
end