module Mode

  type mode = Strict | Unstrict
end

module Behaviour

  use option.Option
  use Mode

  (* No return-behaviour behaviour since we do not implement functions (for now) *)
  type behaviour =
    | BNormal bool
    | BExit bool

  let function behaviour_of_bool : mode -> bool -> behaviour =
    fun strict b ->
      match strict, b with
      | Strict, False -> BExit False
      | _ -> BNormal b
      end

  let function behaviour_of_bool_opt : mode -> option bool -> behaviour =
    fun strict b ->
      match b with
      | Some b' -> behaviour_of_bool strict b'
      | None -> BNormal True
      end

  let function bool_of_behaviour : behaviour -> bool =
    fun b ->
      match b with
      | BNormal b'
      | BExit b' -> b'
      end
end

module Filesystem
  type filesystem
  val constant empty_filesystem: filesystem
end

(** {2 Contexts for the evaluation} *)

module Context

  use list.List
  use map.Map
  use mystring.String
  use bool.Bool

  use syntax.Variable

  use Mode
  use Filesystem
  use Behaviour

  (** {3 Read-only context for the evaluation of a term} *)

  type input = {
    arguments: list string; (* Better an array? Advantages? *)
    previous: bool; (* result of last command, i.e. `$?`, default true *)
    under_condition: bool; (* evaluation below a condition implying unstrict mode *)
  }

  (** Strict evaluation mode ("false is fatal") applies outside of conditions.

      To implement "set -e/+e", a second field indicating the global strict mode
      `strict_mode` has to be added in the context and added in this test as
      `ctx.strict_mode && negb ctx.under_condition` to account for the following example:

      bash --posix -e -c 'if set +e; then echo X; fi; false; echo A/$?'; echo --$?~
  *)
  let function strict : input -> mode =
    fun inp ->
      if notb (inp.under_condition)
      then Strict
      else Unstrict

  (** {3 Read/write context for the evaluation of a term} *)

  type irreversable = {
    filesystem: filesystem;
    stdin: string; (* : @NJ How is this used in Debian scripts? Required interface for stdin? *)
  }

  type state = {irr: irreversable; env: map variable string}

  (* BB: The evaluation state should comprise `filesystem`, `stdin`, and `senv`. The
     `filesystem` and `stdin`, however, are differentin being unreversable parts of the
     system (whatâ€™s done is done, even in subprocesses) but changes in the environment
     may be just ignored (e.g., for subprocesses).

     Other ideas? Better name?

     Or keep together in one record and have a function

     (* A helper to take only the unreversable fields from a subprocess *)
     let function with_unreversable : state -> state -> state =
       fun st1 st2 ->
         {st1 with filesystem = st2.filesystem; stdin = st2.stdin}
  *)

  (** {3 Write-only evaluation of a term} *)

  type output = {
    stdout: string; (* Better implement and use a buffer? *)
    behaviour: behaviour;
  }

  (* Combine a sequence of two outputs, ignoring the behaviour of the first output *)
  let function seq_outputs : output -> output -> output =
    fun out1 out2 ->
      { stdout = out1.stdout ^ out2.stdout;
        behaviour = out2.behaviour }
end

(** {2 Semantics of the CoLiS language} *)

module Semantics

  use list.List
  use list.Append
  use option.Option
  use map.Map

  use mystring.String
  use syntax.Syntax

  use Behaviour
  use Context

  let function bool_of_return_code : return_code -> bool -> bool =
    fun c previous ->
      match c with
      | CSuccess -> True
      | CFailure -> False
      | CPrevious -> previous
      end

  let function get_option opt default =
    match opt with
    | Some v -> v
    | None -> default
    end

  (** Interprete a command defined in the document *Specification of UNIX Commands*.

      It acts upon the input and irreversable state, and returns a stdout, a behaviour
      (True/False), and another irreversable state *)
  val function interp_builtin input irreversable string (list string) :
    (string, bool, irreversable)

  (* Universal variables for results of function applications and constructors in the
     inductive definition below can be replaced by let-bindings when the following bug
     report is resolved:

     https://gitlab.inria.fr/why3/why3/issues/185
   *)

  inductive eval_stmt input state statement state output =

   | eval_assign: forall inp sta irr' sta'' v e s b out.
     eval_expr inp sta e s irr' b ->
     sta'' = {irr = irr'; env = sta.env[v <- s]} ->
     out = {stdout = empty; behaviour = behaviour_of_bool_opt (strict inp) b} ->
     eval_stmt inp sta (SAssignment v e) sta'' out

   | eval_sequence_normal: forall inp sta s1 s2 sta1 sta2 out1 out2 out3 b1.
     eval_stmt inp sta s1 sta1 {out1 with behaviour = BNormal b1} ->
     eval_stmt {inp with previous = b1} sta1 s2 sta2 out2 ->
     out3 = seq_outputs out1 out2 ->
     eval_stmt inp sta (SSequence s1 s2) sta2 out3

   | eval_sequence_abort: forall inp sta s1 s2 sta1 out1 b1.
     match b1 with BExit _ -> true | BNormal _ -> false end ->
     eval_stmt inp sta s1 sta1 {out1 with behaviour = b1} ->
     eval_stmt inp sta (SSequence s1 s2) sta1 out1

   | eval_subshell: forall inp sta sta' sta'' stm out out'.
     eval_stmt inp sta stm sta' out ->
     sta'' = {sta with irr = sta'.irr} ->
     let b = behaviour_of_bool (strict inp) (bool_of_behaviour out.behaviour) in
     out' = {out with behaviour = b} ->
     eval_stmt inp sta (SSubshell stm) sta'' out'

   | eval_if_true: forall inp sta sta1 sta2 s1 s2 s3 out1 out2 out3.
     eval_stmt {inp with under_condition = True} sta s1 sta1 {out1 with behaviour = BNormal True} ->
     eval_stmt {inp with previous = True} sta1 s2 sta2 out2 ->
     out3 = seq_outputs out1 out2 ->
     eval_stmt inp sta (SIf s1 s2 s3) sta2 out3

   | eval_if_false: forall inp sta sta1 sta2 s1 s2 s3 out1 out2 out3.
     eval_stmt {inp with under_condition = True} sta s1 sta1 {out1 with behaviour = BNormal False} ->
     eval_stmt {inp with previous = False} sta1 s3 sta2 out2 ->
     out3 = seq_outputs out1 out2 ->
     eval_stmt inp sta (SIf s1 s2 s3) sta2 out3

   | eval_if_transmit: forall inp sta sta1 s1 s2 s3 b1 out1.
     match b1 with BExit _ -> true | BNormal _ -> false end ->
     eval_stmt {inp with under_condition = True} sta s1 sta1 {out1 with behaviour = b1} ->
     (* Set inp.previous=False? *)
     eval_stmt inp sta (SIf s1 s2 s3) sta1 out1

   | eval_nooutput: forall inp sta sta' st out out'.
     eval_stmt inp sta st sta' out ->
     out = {out with stdout = empty} ->
     eval_stmt inp sta (SNoOutput st) sta' out'

   | eval_pipe: forall inp sta sta1 sta2 s1 s2 out1 out2.
     eval_stmt inp sta s1 sta1 out1 ->
     eval_stmt inp {sta1 with irr = {sta1.irr with stdin = out1.stdout}} s2 sta2 out2 ->
     eval_stmt inp sta (SPipe s1 s2) sta2 out2

   | eval_call: forall inp sta sta' s es ss irr1 irr2 b1 b2 stdout1 out.
     eval_exprs True inp sta es ss irr1 b1 -> (* b1 is ignored *)
     (stdout1, b2, irr2) = interp_builtin inp irr1 s ss ->
     out = {stdout = stdout1; behaviour = behaviour_of_bool (strict inp) b2} ->
     sta' = {irr = irr2; env = sta.env} ->
     eval_stmt inp sta (SCall s es) sta' out

   (* TODO SWhile, SForeach *)
   (* TODO SNot/SNotTrue/SFalse, decide syntax first *)
   (* TODO SExit, decide argument type first *)

  (** Evaluation of an expression to a string *)
  with eval_expr input state expression string irreversable (option bool)  =

    | eval_literal: forall inp sta s. 
      eval_expr inp sta (ELiteral s) s sta.irr None

    | eval_variable: forall inp sta v s.
      s = sta.env[v] ->
      eval_expr inp sta (EVariable v) s sta.irr None

    | eval_esubshell: forall inp sta sta' stm out b.
      eval_stmt inp sta stm sta' out ->
      b = Some (bool_of_behaviour out.behaviour) ->
      eval_expr inp sta (ESubshell stm) out.stdout sta'.irr b

    (* TODO EConcat, but decide first syntax for concat *)

  (** Evaluation of expressions to a list of strings

      CM: reuse `input.previous` instead of `option bool` or at least `bool` with default
      `True`

      BB: Indeed, even shell is using something like input.previous for this - the
      following line prints "A/123-B/0" !

      bash --posix -c 'x=$(exit 123)$(echo A/$?)-$(echo B/$?); echo $x'

      BB: Not really, the following line prints "A/1/0"

      bash --posix -c 'false; x=A/$?; echo $x/$?'
  *)
  with eval_exprs bool input state expressions (list string) irreversable bool =

    | eval_exprs_nil: forall prev inp sta.
      eval_exprs prev inp sta Nil Nil sta.irr prev

    | eval_exprs_cons: forall prev inp sta e sp es s irr1 irr2 bo b l1 l2 l3.
      eval_expr inp sta e s irr1 bo ->
      l1 = (if sp then split s else Cons s Nil) ->
      eval_exprs (get_option bo previous) inp {sta with irr=irr1} es l2 irr2 b ->
      l3 = l1 ++ l2 ->
      eval_exprs prev inp sta (Cons (e, sp) es) l3 irr2 b
end