module Mode
  type mode = Strict | Unstrict
end

module Filesystem
  type filesystem
  val constant empty_filesystem: filesystem
end

module Behaviour

  use option.Option

  use Mode

  (* No return-behaviour behaviour since we do not implement functions (for now) *)
  type behaviour =
    | BNormal bool
    | BExit bool

  let function behaviour_of_bool : mode -> bool -> behaviour =
    fun strict b ->
      match strict, b with
      | Strict, False -> BExit False
      | _ -> BNormal b
      end

  let function behaviour_of_bool_opt : mode -> option bool -> behaviour =
    fun strict b ->
      match b with
      | Some b' -> behaviour_of_bool strict b'
      | None -> BNormal True
      end

  let function bool_of_behaviour : behaviour -> bool =
    fun b ->
      match b with
      | BNormal b'
      | BExit b' -> b'
      end
end

(** {2 Contexts for the evaluation} *)

module Context

  use array.Array
  use map.Map
  use map.Const
  use mystring.String
  use bool.Bool

  use mystring.String
  use syntax.Variable

  use Mode
  use Filesystem
  use Behaviour

  (* Better implement and use a buffer? *)
  type stdin = Stdin string 

  let constant empty_stdin = Stdin String.empty

  type stdout = Stdout string 

  let constant empty_stdout = Stdout String.empty

  let function stdout_to_stdin =
    fun s -> match s with Stdout s -> Stdin s end

  (** {3 Read-only context for the evaluation of a term} *)

  type input = {
    arguments: array string;
    previous: bool; (* result of last command, i.e. `$?`, default `True` *)
    under_condition: bool; (* evaluation under condition - implying unstrict mode *)
  }

  let constant empty_input = {
    arguments = Array.make 0 String.empty;
    previous = True;
    under_condition = False;
  }

  (** {3 Read/write context for the evaluation of a term} *)

  (** The state is unreversable, i.e. following a linear logic, each internal state should
      be consumed exactly once *)
  type state = {
    filesystem: filesystem;
    stdin: stdin; (* : @NJ How is this used in Debian scripts? Required interface for stdin? *)
  }

  let constant empty_state = {
    filesystem = empty_filesystem;
    stdin = empty_stdin;
  }

  (** The context of the interpretation, resulting contexts may be ignored (e.g., from
      subprocesses) *)
  type context = {
    env: map variable string
  }

  let constant empty_context = {
    env = const String.empty;
  }

  (** {3 Write-only evaluation of a term} *)

  type output = {
    stdout: stdout; 
    behaviour: behaviour;
  }

  (** {3 Auxiliaries} *)

  (** Strict evaluation mode ("false is fatal") currently applies only outside of
      conditions.

      To implement "set -e/+e", a second field indicating the global strict mode
      (`strict_mode`) has to be added in the state and added in this test as
      `ctx.strict_mode && negb ctx.under_condition` to account for the following example:

      bash --posix -e -c 'if set +e; then echo X; fi; false; echo A/$?'; echo --$?~ *)
  let function strict : input -> mode =
    fun inp ->
      if notb (inp.under_condition)
      then Strict
      else Unstrict

  (** Combine a sequence of two outputs, ignoring the behaviour of the first output *)
  let function seq_outputs : output -> output -> output =
    fun out1 out2 ->
      match out1, out2 with
      | {stdout = Stdout s1}, {stdout = Stdout s2; behaviour = b} ->
        {stdout = Stdout (s1 ^ s2); behaviour = b}
      end
end

(** {2 Semantics of the CoLiS language} *)

module Semantics

  use list.List
  use list.Append
  use option.Option
  use map.Map

  use mystring.String
  use syntax.Syntax

  use Behaviour
  use Context

  let function bool_of_return_code : return_code -> bool -> bool =
    fun c previous ->
      match c with
      | CSuccess -> True
      | CFailure -> False
      | CPrevious -> previous
      end

  let function get_option opt default =
    match opt with
    | Some v -> v
    | None -> default
    end

  (** Interprete a command defined in the document *Specification of UNIX Commands*.

      It acts upon the input and irreversable state, and returns a stdout, a behaviour
      (True/False), and another irreversable state *)

  val function interp_builtin input state string (list string) :
    (state, stdout, bool)


  (** Evaluation of a statement s with input I, context C and state S resulting in an
      state S', context C', and output O:

      \[ (I, C, S) s \Downarrow (S', C', O) \]
   *)

  (** Universal variables for results of function applications and constructors in the
      inductive definition below can be replaced by let-bindings when the following bug
      report is resolved:

      https://gitlab.inria.fr/why3/why3/issues/185
   *)

  inductive eval_stmt input context state statement state context output =

  | eval_assign: forall inp ctx ctx' sta sta' v e s b out.
    eval_expr inp ctx sta e sta' s b ->
    ctx' = {ctx with env = ctx.env[v <- s]} ->
    out = {stdout = empty_stdout; behaviour = behaviour_of_bool_opt (strict inp) b} ->
    eval_stmt inp ctx sta (SAssignment v e) sta' ctx' out
  
  | eval_sequence_normal: forall inp sta sta1 sta2 s1 s2 ctx ctx1 ctx2 out1 out2 out3 b1.
    eval_stmt inp ctx sta s1 sta1 ctx1 {out1 with behaviour = BNormal b1} ->
    eval_stmt {inp with previous = b1} ctx1 sta1 s2 sta2 ctx2 out2 ->
    out3 = seq_outputs out1 out2 ->
    eval_stmt inp ctx sta (SSequence s1 s2) sta2 ctx out3
  
  | eval_sequence_abort: forall inp sta sta1 ctx ctx1 s1 s2 out1 b1.
    match b1 with BExit _ -> true | BNormal _ -> false end ->
    eval_stmt inp ctx sta s1 sta1 ctx1 {out1 with behaviour = b1} ->
    eval_stmt inp ctx sta (SSequence s1 s2) sta1 ctx1 out1
  
  | eval_subshell: forall inp sta sta' ctx ctx' stm out out' b.
    eval_stmt inp ctx sta stm sta' ctx' out ->
    (* `Normal false` turns to `Exit False` in strict mode - the line `set -e; (! true);
       echo A/$?` prints nothing *)
    b = behaviour_of_bool (strict inp) (bool_of_behaviour out.behaviour) ->
    out' = {out with behaviour = b} -> 
    eval_stmt inp ctx sta (SSubshell stm) sta' ctx out'
  
  | eval_if_true: forall inp ctx ctx1 ctx2 sta sta1 sta2 s1 s2 s3 out1 out2 out3.
    eval_stmt {inp with under_condition = True} ctx sta s1 sta1 ctx1 {out1 with behaviour = BNormal True} ->
    eval_stmt {inp with previous = True} ctx1 sta1 s2 sta2 ctx2 out2 ->
    out3 = seq_outputs out1 out2 ->
    eval_stmt inp ctx sta (SIf s1 s2 s3) sta2 ctx2 out3
  
  | eval_if_false: forall inp ctx ctx1 ctx2 sta sta1 sta2 s1 s2 s3 out1 out2 out3.
    eval_stmt {inp with under_condition = True} ctx sta s1 sta1 ctx1 {out1 with behaviour = BNormal False} ->
    eval_stmt {inp with previous = False} ctx1 sta1 s3 sta2 ctx2 out2 ->
    out3 = seq_outputs out1 out2 ->
    eval_stmt inp ctx sta (SIf s1 s2 s3) sta2 ctx2 out3
  
  | eval_if_transmit: forall inp ctx ctx1 sta sta1 s1 s2 s3 b1 out1.
    match b1 with BExit _ -> true | BNormal _ -> false end ->
    eval_stmt {inp with under_condition = True} ctx sta s1 sta1 ctx1 {out1 with behaviour = b1} ->
    eval_stmt inp ctx sta (SIf s1 s2 s3) sta1 ctx1 out1
  
  | eval_nooutput: forall inp ctx ctx' sta sta' st out out'.
    eval_stmt inp ctx sta st sta' ctx' out ->
    out = {out with stdout = empty_stdout} ->
    eval_stmt inp ctx sta (SNoOutput st) sta' ctx' out'
  
  (** ignores changes in the context `ctx` *)
  (** TODO does not set `$?` *)
  | eval_pipe: forall inp ctx ctx1 ctx2 sta sta1 sta2 s1 s2 out1 out2.
    eval_stmt inp ctx sta s1 sta1 ctx1 out1 ->
    eval_stmt inp ctx {sta1 with stdin = stdout_to_stdin out1.stdout} s2 sta2 ctx2 out2 ->
    eval_stmt inp ctx sta (SPipe s1 s2) sta2 ctx out2
  
  | eval_call: forall inp ctx sta sta' s es ss b b' sout out.
    eval_exprs True inp ctx sta es sta' ss b -> (* ignore b *)
    (sta', sout, b') = interp_builtin inp sta s ss ->
    out = {stdout = sout; behaviour = behaviour_of_bool (strict inp) b'} ->
    eval_stmt inp ctx sta (SCall s es) sta' ctx out
  
  (* TODO the behaviour of eval_exprs seems to be the `previous` for the for-body: the
     script `for x in $(exit 2)a; do echo $x/$?; done` prints `a/2`. *)
  | eval_foreach: forall inp ctx ctx' sta sta' sta'' v es stm ss b out.
    eval_exprs True inp ctx sta es sta' ss b -> 
    eval_foreach {inp with previous = b} ctx sta' v ss stm sta'' ctx' out ->
    eval_stmt inp ctx sta (SForeach v es stm) sta'' ctx' out

  (** while-condition is false *)
  | eval_while_false: forall inp ctx ctx1 sta sta1 s1 s2 out1 out2.
    eval_stmt {inp with under_condition = True} ctx sta s1 sta1 ctx1 {out1 with behaviour = BNormal False} ->
    out2 = {out1 with behaviour = BNormal True} -> (** TODO correct? `false; while false; do false; done; echo X/$?` prints `X/0` *)
    eval_stmt inp ctx sta (SWhile s1 s2) sta1 ctx1 out2

  (** while-condition is not normal *)
  | eval_while_transmit: forall inp ctx ctx1 sta sta1 s1 s2 out1 b.
    match b with BExit _ -> true | BNormal _ -> false end ->
    eval_stmt {inp with under_condition = True} ctx sta s1 sta1 ctx1 {out1 with behaviour = b} ->
    eval_stmt inp ctx sta (SWhile s1 s2) sta1 ctx1 out1

  (** while-condition true but while-body not normal *)
  | eval_while_true_transmit: forall inp ctx ctx1 ctx2 sta sta1 sta2 s1 s2 out1 out2 b.
    match b with BExit _ -> true | BNormal _ -> false end ->
    eval_stmt {inp with under_condition = True} ctx sta s1 sta1 ctx1 {out1 with behaviour = b} ->
    eval_stmt inp ctx1 sta1 s2 sta2 ctx2 {out2 with behaviour = b} ->
    eval_stmt inp ctx sta (SWhile s1 s2) sta2 ctx2 out2

  (** while-condition true, body normal, and loop again *)
  | eval_while_true_loop: forall inp ctx ctx1 ctx2 ctx3 sta sta1 sta2 sta3 s1 s2 out1 out2 out3 b.
    eval_stmt {inp with under_condition = True} ctx sta s1 sta1 ctx1 {out1 with behaviour = BNormal True} ->
    eval_stmt inp ctx1 sta1 s2 sta2 ctx2 {out2 with behaviour = BNormal b} ->
    (* c.f. below `function f() { return $1; }; for x in 0 1 2; do echo X/$x/$?; f $x; done; echo Y/$x/$?` *)
    eval_stmt {inp with previous = b} ctx2 sta2 (SWhile s1 s2) sta3 ctx3 out3 ->
    eval_stmt inp ctx sta (SWhile s1 s2) sta3 ctx3 out3

   (* TODO SNot/SNotTrue/SFalse, decide syntax first *)
   (* TODO SExit, decide argument type first *)

  with eval_foreach input context state variable (list string) statement state context output =

  | eval_foreach_nil: forall inp ctx sta x stm out.
    out = {stdout = empty_stdout; behaviour = BNormal True} ->
    eval_foreach inp ctx sta x Nil stm sta ctx out

  | eval_foreach_cons: forall inp ctx ctx1 ctx2 sta sta1 sta2 x s ss stm out1 out2.
    eval_stmt inp {ctx with env = ctx.env[x <- s]} sta stm sta1 ctx1 out1 ->
    eval_foreach inp ctx1 sta1 x ss stm sta2 ctx2 out2 ->
    eval_foreach inp ctx sta x (Cons s ss) stm sta2 ctx2 out2

  (** Evaluation of an expression with some input I, context C, and state S, resulting in
      another state S, a string and an output comprised of a string result and an optional
      boolean behaviour (only $(...) has a behaviour):

      \[ (I, C, S) e \Downarrow S, String, OptBool \]
   *)
  with eval_expr input context state expression state string (option bool)  =

  | eval_literal: forall inp ctx sta s. 
    eval_expr inp ctx sta (ELiteral s) sta s None

  | eval_variable: forall inp ctx sta v s.
    s = ctx.env[v] ->
    eval_expr inp ctx sta (EVariable v) sta s None

  | eval_esubshell: forall inp ctx ctx' sta sta' stm out s b.
    eval_stmt inp ctx sta stm sta' ctx' {out with stdout = Stdout s} ->
    b = Some (bool_of_behaviour out.behaviour) ->
    eval_expr inp ctx sta (ESubshell stm) sta' s b

    (* TODO EConcat, but decide first syntax for concat *)

  (** Evaluation of expressions to a list of strings:

      \[ (Bool, I, C, S) es \Downarrow (S, StringList, Bool) \]

      CM: reuse `input.previous` instead of `option bool` or at least `bool` with default
      `True`

      BB: Indeed, even shell is using something like input.previous for this - the
      following line prints "A/123-B/0" !

      bash --posix -c 'x=$(exit 123)$(echo A/$?)-$(echo B/$?); echo $x'

      BB: Not really, the following line prints "A/1/0"

      bash --posix -c 'false; x=A/$?; echo $x/$?'
  *)
  with eval_exprs bool input context state expressions state (list string) bool =

    | eval_exprs_nil: forall prev inp ctx sta.
      eval_exprs prev inp ctx sta Nil sta Nil prev

    | eval_exprs_cons: forall prev inp ctx sta sta' sta'' e sp es s bo b l1 l2 l3.
      eval_expr inp ctx sta e sta' s bo ->
      l1 = (match sp with Split -> split s | NoSplit -> Cons s Nil end) ->
      eval_exprs (get_option bo prev) inp ctx sta' es sta'' l2 b ->
      l3 = l1 ++ l2 ->
      eval_exprs prev inp ctx sta (Cons (e, sp) es) sta' l3 b
end