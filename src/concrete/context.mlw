module Context

  use list.List
  use bool.Bool
  use mystring.String
  use map.Map
  use map.Const

  use syntax.Syntax

  type filesystem
  val constant empty_filesystem: filesystem

  (* Split context into elements that are shared between siblings in the AST during
     evaluation, and elements that are always local to one branch (i.e., under_condition)? *)
  type context = {
    filesystem: filesystem;
    (* Program input *)
    args: list string; (* Better an array? Advantages? *)
    stdin: string; (* BB TODO: NJ, How is this used in Debian scripts? *)
    (* Evaluation context *)
    senv: map variable string;
    previous: bool; (* result of last command `$?` *)
    under_condition: bool; (* better as parameter/argument in evaluation? *)
  }

  let constant empty_context = {
    filesystem = empty_filesystem;
    args = Nil;
    stdin = String.empty; 
    senv = Const.const String.empty;
    under_condition = False;
    previous = True;
  }

  (** `with_unreversable ctx1 ctx2` returns `ctx1` with unreversable fields from `ctx2`
      (i.e., `stdin`, `filesystem`).

      This is required for defining the semantics of subshells (in expressions and
      statements).

      Should we have instead a field with unreversable data in the context?
  *)
  let function with_unreversable ctx1 ctx2 =
    {ctx1 with filesystem = ctx2.filesystem; stdin = ctx2.stdin}

  (** Strict evaluation mode ("false is fatal") applies outside of conditions.

      To implement "set -x/+x", a second field indicating the global strict mode
      `strict_mode` has to be added in the context and added in this test as
      `ctx.strict_mode && negb ctx.under_condition` *)
  let function strict ctx =
    notb (ctx.under_condition)

end